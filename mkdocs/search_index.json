{
    "docs": [
        {
            "location": "/",
            "text": "zend-soap\n\n\n\n\n\n\nZend\\Soap\n is a component to manage the \nSOAP\n\nprotocol in order to design client or server PHP application.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-soap/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-soap/",
            "title": "Home"
        },
        {
            "location": "/#zend-soap",
            "text": "Zend\\Soap  is a component to manage the  SOAP \nprotocol in order to design client or server PHP application.   File issues at https://github.com/zendframework/zend-soap/issues  Documentation is at https://zendframework.github.io/zend-soap/",
            "title": "zend-soap"
        },
        {
            "location": "/server/",
            "text": "Zend\\Soap\\Server\n\n\nZend\\Soap\\Server\n provides a wrapper around PHP's\n\nSoapServer\n implementation with convenience\nfunctionality for generating WSDL and registering internal handlers.\n\n\nIt may be used in WSDL or non-WSDL mode, and can map functionality to either PHP\nclasses or functions in order to define your web service API.\n\n\nWhen in WSDL mode, it uses a prepared WSDL document to define server object\nbehavior and transport layer options.\n\n\nWSDL documents may be auto-generated with functionality provided by the\n\nZend\\Soap\\AutoDiscover\n component, or constructed manually\nusing the \nZend\\Soap\\Wsdl\n class or any other XML generation tool.\n\n\nIf the non-WSDL mode is used, then all protocol options must be provided via the\noptions mechanism.\n\n\nZend\\Soap\\Server instantiation\n\n\nInstantiation of \nServer\n instances varies based on whether or not you are using\nWSDL mode.\n\n\nInstantiation for WSDL mode\n\n\nWhen in WSDL mode, the constructor expects two optional paramters:\n\n\n\n\n$wsdl\n: the URI of a WSDL file. This may be set after-the-fact using\n  \n$server->setWsdl($wsdl)\n.\n\n\n$options\n: options to use when creating the instance. These may be set later\n  using \n$server->setOptions($options)\n.\n\n\n\n\nThe following options are recognized in the WSDL mode:\n\n\n\n\nsoap_version\n (\nsoapVersion\n) - soap version to use (\nSOAP_1_1\n or \nSOAP_1_2\n).\n\n\nactor\n - the actor URI for the server.\n\n\nclassmap\n (\nclassMap\n) which can be used to map some WSDL types to PHP\n  classes. The option must be an array with WSDL types as keys, and names of PHP\n  classes as values.\n\n\nencoding\n - internal character encoding (UTF-8 is always used as an external encoding).\n\n\nwsdl\n - equivalent to calling \nsetWsdl($wsdlValue)\n.\n\n\n\n\nInstantiation for non-WSDL mode\n\n\nThe first constructor parameter \nmust\n be set to \nNULL\n if you plan to use\n\nZend\\Soap\\Server\n functionality in non-WSDL mode.\n\n\nYou also have to set the \nuri\n option in this case (see below).\n\n\nThe second constructor parameter, \n$options\n, is an array of options for\nconfiguring the behavior of the server; these may also be provided later using\n\n$server->setOptions($options)\n. Options recognized in non-WSDL mode include:\n\n\n\n\nsoap_version\n (\nsoapVersion\n) - soap version to use (\nSOAP_1_1\n or \nSOAP_1_2\n).\n\n\nactor\n - the actor URI for the server.\n\n\nclassmap\n (\nclassMap\n) - an associative array used to map WSDL types to PHP\n  classes. The option must be an associative array using WSDL types as the\n  keys, and PHP class names as values.\n\n\nencoding\n - internal character encoding (UTF-8 is always used as an external\n  encoding).\n\n\nuri\n (required) - URI namespace for SOAP server.\n\n\n\n\nDefining your SOAP API\n\n\nThere are two ways to define your SOAP API in order to expose PHP functionality.\n\n\nThe first one is to attach a class to the \nZend\\Soap\\Server\n object that\ncompletely describes your API:\n\n\nclass MyClass\n{\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam\n     * @return string\n     */\n    public function method1($inputParam)\n    {\n        // ...\n    }\n\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam1\n     * @param string  $inputParam2\n     * @return float\n     */\n    public function method2($inputParam1, $inputParam2)\n    {\n        // ...\n    }\n\n    /* ... */\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n\n// Bind class to Soap Server:\n$server->setClass(MyClass::class);\n\n// Or bind an instance:\n$server->setObject(new MyClass());\n\n// Handle a request:\n$server->handle();\n\n\n\n\n\n\nDocblocks are required\n\n\nYou should completely describe each method using a method docblock if you plan\nto use autodiscover functionality to prepare your WSDL.\n\n\n\n\nThe second method for defining your API is to use one or more functions, passing\nthem to one or more of the \naddFunction()\n or \nloadFunctions()\n methods:\n\n\n/**\n * This function ...\n *\n * @param integer $inputParam\n * @return string\n */\nfunction function1($inputParam)\n{\n    // ...\n}\n\n/**\n * This function ...\n *\n * @param integer $inputParam1\n * @param string  $inputParam2\n * @return float\n */\nfunction function2($inputParam1, $inputParam2)\n{\n    // ...\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n$server->addFunction('function1');\n$server->addFunction('function2');\n\n$server->handle();\n\n\n\n\nRequest and response handling\n\n\nZend\\Soap\\Server\n component performs request/response processing automatically,\nbut allows you to intercept each in order to perform pre- or post-processing.\n\n\nRequest pre- and post-processing\n\n\nThe \nZend\\Soap\\Server::handle()\n method handles a request from the standard\ninput stream ('php://input'). It may be overridden either by supplying a request\ninstance to the \nhandle()\n method, or by setting the request via the\n\nsetRequest()\n method:\n\n\n$server = new Zend\\Soap\\Server(/* ... */);\n\n// Set request using optional $request parameter to the handle() method:\n$server->handle($request);\n\n// Set request using setRequest() method:\n$server->setRequest();\n$server->handle();\n\n\n\n\nA request object may be represented using any of the following, and handled as\nfollows:\n\n\n\n\nDOMDocument\n (casts to XML)\n\n\nDOMNode\n (owner document is retrieved and cast to XML)\n\n\nSimpleXMLElement\n (casts to XML)\n\n\nstdClass\n (\n__toString()\n is called and verified to be valid XML)\n\n\nstring\n (verified to be valid XML)\n\n\n\n\nThe last request processed may be retrieved using the \ngetLastRequest()\n method,\nwhich returns the XML string:\n\n\n$server = new Zend\\Soap\\Server(/* ... */);\n\n$server->handle();\n$request = $server->getLastRequest();\n\n\n\n\nResponse post-processing\n\n\nThe \nZend\\Soap\\Server::handle()\n method automatically emits the generated\nresponse to the output stream. It may be blocked using \nsetReturnResponse()\n\nwith \ntrue\n or \nfalse\n as a parameter. When set to \ntrue\n, \nhandle()\n will\nreturn the generated response instead of emitting it.\n\n\nThe returned response will be either an XML string representing the response, or\na \nSoapFault\n exception instance.\n\n\n\n\nDo not return SoapFaults\n\n\nSoapFault instances, when cast to a string, will contain the full exception\nstack trace. For security purposes, you do not want to return that\ninformation. As such, check your return type before emitting the response\nmanually.\n\n\n\n\n$server = new Zend\\Soap\\Server(/* ... */);\n\n// Get a response as a return value of handle(),\n// instead of emitting it to standard output:\n$server->setReturnResponse(true);\n\n$response = $server->handle();\n\nif ($response instanceof SoapFault) {\n    /* ... */\n} else {\n    /* ... */\n}\n\n\n\n\nThe last response emitted may also be retrieved for post-processing using\n\ngetLastResponse()\n:\n\n\n$server = new Zend\\Soap\\Server(/* ... */);\n\n$server->handle();\n\n$response = $server->getLastResponse();\n\nif ($response instanceof SoapFault) {\n    /* ... */\n} else {\n    /* ... */\n}\n\n\n\n\nDocument/Literal WSDL Handling\n\n\nThe document/literal binding-style/encoding pattern is used to make SOAP\nmessages as human-readable as possible and allow abstraction between very\nincompatible languages. The .NET framework uses this pattern for SOAP service\ngeneration by default. The central concept of this approach to SOAP is the\nintroduction of a Request and an Response object for every function/method of\nthe SOAP service. The parameters of the function are properties on the request\nobject, and the response object contains a single parameter that is built in the\nstyle \n<methodName>Result\n\n\nzend-soap supports this pattern in both the AutoDiscover and Server\ncomponents. You can write your service object without knowledge of the pattern.\nUse docblock comments to hint the parameter and return types as usual. The\n\nZend\\Soap\\Server\\DocumentLiteralWrapper\n wraps around your service object and\nconverts request and response into normal method calls on your service.\n\n\nSee the class doc block of the \nDocumentLiteralWrapper\n for a detailed example\nand discussion.",
            "title": "Servers"
        },
        {
            "location": "/server/#zend92soap92server",
            "text": "Zend\\Soap\\Server  provides a wrapper around PHP's SoapServer  implementation with convenience\nfunctionality for generating WSDL and registering internal handlers.  It may be used in WSDL or non-WSDL mode, and can map functionality to either PHP\nclasses or functions in order to define your web service API.  When in WSDL mode, it uses a prepared WSDL document to define server object\nbehavior and transport layer options.  WSDL documents may be auto-generated with functionality provided by the Zend\\Soap\\AutoDiscover  component, or constructed manually\nusing the  Zend\\Soap\\Wsdl  class or any other XML generation tool.  If the non-WSDL mode is used, then all protocol options must be provided via the\noptions mechanism.",
            "title": "Zend\\Soap\\Server"
        },
        {
            "location": "/server/#zendsoapserver-instantiation",
            "text": "Instantiation of  Server  instances varies based on whether or not you are using\nWSDL mode.",
            "title": "Zend\\Soap\\Server instantiation"
        },
        {
            "location": "/server/#instantiation-for-wsdl-mode",
            "text": "When in WSDL mode, the constructor expects two optional paramters:   $wsdl : the URI of a WSDL file. This may be set after-the-fact using\n   $server->setWsdl($wsdl) .  $options : options to use when creating the instance. These may be set later\n  using  $server->setOptions($options) .   The following options are recognized in the WSDL mode:   soap_version  ( soapVersion ) - soap version to use ( SOAP_1_1  or  SOAP_1_2 ).  actor  - the actor URI for the server.  classmap  ( classMap ) which can be used to map some WSDL types to PHP\n  classes. The option must be an array with WSDL types as keys, and names of PHP\n  classes as values.  encoding  - internal character encoding (UTF-8 is always used as an external encoding).  wsdl  - equivalent to calling  setWsdl($wsdlValue) .",
            "title": "Instantiation for WSDL mode"
        },
        {
            "location": "/server/#instantiation-for-non-wsdl-mode",
            "text": "The first constructor parameter  must  be set to  NULL  if you plan to use Zend\\Soap\\Server  functionality in non-WSDL mode.  You also have to set the  uri  option in this case (see below).  The second constructor parameter,  $options , is an array of options for\nconfiguring the behavior of the server; these may also be provided later using $server->setOptions($options) . Options recognized in non-WSDL mode include:   soap_version  ( soapVersion ) - soap version to use ( SOAP_1_1  or  SOAP_1_2 ).  actor  - the actor URI for the server.  classmap  ( classMap ) - an associative array used to map WSDL types to PHP\n  classes. The option must be an associative array using WSDL types as the\n  keys, and PHP class names as values.  encoding  - internal character encoding (UTF-8 is always used as an external\n  encoding).  uri  (required) - URI namespace for SOAP server.",
            "title": "Instantiation for non-WSDL mode"
        },
        {
            "location": "/server/#defining-your-soap-api",
            "text": "There are two ways to define your SOAP API in order to expose PHP functionality.  The first one is to attach a class to the  Zend\\Soap\\Server  object that\ncompletely describes your API:  class MyClass\n{\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam\n     * @return string\n     */\n    public function method1($inputParam)\n    {\n        // ...\n    }\n\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam1\n     * @param string  $inputParam2\n     * @return float\n     */\n    public function method2($inputParam1, $inputParam2)\n    {\n        // ...\n    }\n\n    /* ... */\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n\n// Bind class to Soap Server:\n$server->setClass(MyClass::class);\n\n// Or bind an instance:\n$server->setObject(new MyClass());\n\n// Handle a request:\n$server->handle();",
            "title": "Defining your SOAP API"
        },
        {
            "location": "/server/#docblocks-are-required",
            "text": "You should completely describe each method using a method docblock if you plan\nto use autodiscover functionality to prepare your WSDL.   The second method for defining your API is to use one or more functions, passing\nthem to one or more of the  addFunction()  or  loadFunctions()  methods:  /**\n * This function ...\n *\n * @param integer $inputParam\n * @return string\n */\nfunction function1($inputParam)\n{\n    // ...\n}\n\n/**\n * This function ...\n *\n * @param integer $inputParam1\n * @param string  $inputParam2\n * @return float\n */\nfunction function2($inputParam1, $inputParam2)\n{\n    // ...\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n$server->addFunction('function1');\n$server->addFunction('function2');\n\n$server->handle();",
            "title": "Docblocks are required"
        },
        {
            "location": "/server/#request-and-response-handling",
            "text": "Zend\\Soap\\Server  component performs request/response processing automatically,\nbut allows you to intercept each in order to perform pre- or post-processing.",
            "title": "Request and response handling"
        },
        {
            "location": "/server/#request-pre-and-post-processing",
            "text": "The  Zend\\Soap\\Server::handle()  method handles a request from the standard\ninput stream ('php://input'). It may be overridden either by supplying a request\ninstance to the  handle()  method, or by setting the request via the setRequest()  method:  $server = new Zend\\Soap\\Server(/* ... */);\n\n// Set request using optional $request parameter to the handle() method:\n$server->handle($request);\n\n// Set request using setRequest() method:\n$server->setRequest();\n$server->handle();  A request object may be represented using any of the following, and handled as\nfollows:   DOMDocument  (casts to XML)  DOMNode  (owner document is retrieved and cast to XML)  SimpleXMLElement  (casts to XML)  stdClass  ( __toString()  is called and verified to be valid XML)  string  (verified to be valid XML)   The last request processed may be retrieved using the  getLastRequest()  method,\nwhich returns the XML string:  $server = new Zend\\Soap\\Server(/* ... */);\n\n$server->handle();\n$request = $server->getLastRequest();",
            "title": "Request pre- and post-processing"
        },
        {
            "location": "/server/#response-post-processing",
            "text": "The  Zend\\Soap\\Server::handle()  method automatically emits the generated\nresponse to the output stream. It may be blocked using  setReturnResponse() \nwith  true  or  false  as a parameter. When set to  true ,  handle()  will\nreturn the generated response instead of emitting it.  The returned response will be either an XML string representing the response, or\na  SoapFault  exception instance.",
            "title": "Response post-processing"
        },
        {
            "location": "/server/#do-not-return-soapfaults",
            "text": "SoapFault instances, when cast to a string, will contain the full exception\nstack trace. For security purposes, you do not want to return that\ninformation. As such, check your return type before emitting the response\nmanually.   $server = new Zend\\Soap\\Server(/* ... */);\n\n// Get a response as a return value of handle(),\n// instead of emitting it to standard output:\n$server->setReturnResponse(true);\n\n$response = $server->handle();\n\nif ($response instanceof SoapFault) {\n    /* ... */\n} else {\n    /* ... */\n}  The last response emitted may also be retrieved for post-processing using getLastResponse() :  $server = new Zend\\Soap\\Server(/* ... */);\n\n$server->handle();\n\n$response = $server->getLastResponse();\n\nif ($response instanceof SoapFault) {\n    /* ... */\n} else {\n    /* ... */\n}",
            "title": "Do not return SoapFaults"
        },
        {
            "location": "/server/#documentliteral-wsdl-handling",
            "text": "The document/literal binding-style/encoding pattern is used to make SOAP\nmessages as human-readable as possible and allow abstraction between very\nincompatible languages. The .NET framework uses this pattern for SOAP service\ngeneration by default. The central concept of this approach to SOAP is the\nintroduction of a Request and an Response object for every function/method of\nthe SOAP service. The parameters of the function are properties on the request\nobject, and the response object contains a single parameter that is built in the\nstyle  <methodName>Result  zend-soap supports this pattern in both the AutoDiscover and Server\ncomponents. You can write your service object without knowledge of the pattern.\nUse docblock comments to hint the parameter and return types as usual. The Zend\\Soap\\Server\\DocumentLiteralWrapper  wraps around your service object and\nconverts request and response into normal method calls on your service.  See the class doc block of the  DocumentLiteralWrapper  for a detailed example\nand discussion.",
            "title": "Document/Literal WSDL Handling"
        },
        {
            "location": "/client/",
            "text": "Zend\\Soap\\Client\n\n\nThe \nZend\\Soap\\Client\n class simplifies SOAP client development for PHP\nprogrammers, and may be used in either WSDL or non-WSDL mode.\n\n\nUnder WSDL mode, \nZend\\Soap\\Client\n uses a WSDL document to define transport\nlayer options.\n\n\nThe WSDL description is usually provided by the web service the client will\naccess.  If the WSDL description is not made available, you may want to use\n\nZend\\Soap\\Client\n in non-WSDL mode. Under this mode, all SOAP protocol options\nhave to be set explicitly on the \nZend\\Soap\\Client\n class.\n\n\nInstantiation\n\n\nThe \nZend\\Soap\\Client\n constructor takes two parameters:\n\n\n\n\n$wsdl\n - the URI of a WSDL file.\n\n\n$options\n - options for modifying the behavior of the client instance.\n\n\n\n\nBoth of these parameters may be set later using the \nsetWsdl($wsdl)\n and\n\nsetOptions($options)\n methods respectively.\n\n\n\n\nNon-WSDL mode requirements\n\n\nIf you use \nZend\\Soap\\Client\n component in non-WSDL mode, you \nmust\n set the\n'location' and 'uri' options.\n\n\n\n\nThe following options are recognized:\n\n\n\n\nsoap_version\n (\nsoapVersion\n) - soap version to use (\nSOAP_1_1\n or\n  \nSOAP_1_2\n).\n\n\nclassmap\n (\nclassMap\n) - maps WSDL types to PHP classes; option must be an\n  array where keys are the WSDL types, and values are the PHP class to which\n  to map.\n\n\nencoding\n - internal character encoding (UTF-8 is always used as an external\n  encoding).\n\n\nwsdl\n - specifying this option sets the client in WSDL mode. Can be set\n  after-the-fact using \nsetWsdl($wsdl)\n.\n\n\nuri\n - target namespace for the SOAP service (required for non-WSDL-mode;\n  no-op when in WSDL mode).\n\n\nlocation\n - the URL to request (required for non-WSDL-mode; no-op when in\n  WSDL mode).\n\n\nstyle\n - request style (non-WSDL mode only); one of \nSOAP_RPC\n or\n  \nSOAP_DOCUMENT\n.\n\n\nuse\n - method to use when encoding messages (non-WSDL mode only);\n  either \nSOAP_ENCODED\n or \nSOAP_LITERAL\n.\n\n\nlogin\n and \npassword\n - login and password for HTTP authentication.\n\n\nproxy_host\n, \nproxy_port\n, \nproxy_login\n, and \nproxy_password\n - use when\n  specifying a service behind a proxy server.\n\n\nlocal_cert\n and \npassphrase\n - HTTPS client certificate authentication\n  options.\n\n\ncompression\n - compression options; combination of\n  \nSOAP_COMPRESSION_ACCEPT\n, \nSOAP_COMPRESSION_GZIP\n and/or\n  \nSOAP_COMPRESSION_DEFLATE\n options.\n\n\n\n\nThe following demonstrate usage of compression options:\n\n\n// Accept response compression\n$client = new Zend\\Soap\\Client(\n    'some.wsdl',\n    ['compression' => SOAP_COMPRESSION_ACCEPT]\n);\n\n// Compress requests using gzip with compression level 5\n$client = new Zend\\Soap\\Client(\n    'some.wsdl',\n    ['compression' => SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GZIP | 5]\n);\n\n// Compress requests using deflate compression\n$client = new Zend\\Soap\\Client(\n    \"some.wsdl\",\n    ['compression' => SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_DEFLATE]\n);\n\n\n\n\nPerforming SOAP Requests\n\n\nAfter we've created a \nZend\\Soap\\Client\n instance, we can perform SOAP requests.\n\n\nEach web service method is mapped to a virtual \nZend\\Soap\\Client\n instance\nmethod which takes parameters with common PHP types.\n\n\nAs an example, given the following server:\n\n\nclass MyClass\n{\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam\n     * @return string\n     */\n    public function method1($inputParam)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam1\n     * @param string  $inputParam2\n     * @return float\n     */\n    public function method2($inputParam1, $inputParam2)\n    {\n        /* ... */\n    }\n\n    /* ... */\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n$server->setClass('MyClass');\n$server->handle();\n\n\n\n\nWe can write a client as follows:\n\n\n$client = new Zend\\Soap\\Client(\"MyService.wsdl\");\n\n// $result1 is a string\n$result1 = $client->method1(10);\n\n// $result2 is a float\n$result2 = $client->method2(22, 'some string');",
            "title": "Clients"
        },
        {
            "location": "/client/#zend92soap92client",
            "text": "The  Zend\\Soap\\Client  class simplifies SOAP client development for PHP\nprogrammers, and may be used in either WSDL or non-WSDL mode.  Under WSDL mode,  Zend\\Soap\\Client  uses a WSDL document to define transport\nlayer options.  The WSDL description is usually provided by the web service the client will\naccess.  If the WSDL description is not made available, you may want to use Zend\\Soap\\Client  in non-WSDL mode. Under this mode, all SOAP protocol options\nhave to be set explicitly on the  Zend\\Soap\\Client  class.",
            "title": "Zend\\Soap\\Client"
        },
        {
            "location": "/client/#instantiation",
            "text": "The  Zend\\Soap\\Client  constructor takes two parameters:   $wsdl  - the URI of a WSDL file.  $options  - options for modifying the behavior of the client instance.   Both of these parameters may be set later using the  setWsdl($wsdl)  and setOptions($options)  methods respectively.",
            "title": "Instantiation"
        },
        {
            "location": "/client/#non-wsdl-mode-requirements",
            "text": "If you use  Zend\\Soap\\Client  component in non-WSDL mode, you  must  set the\n'location' and 'uri' options.   The following options are recognized:   soap_version  ( soapVersion ) - soap version to use ( SOAP_1_1  or\n   SOAP_1_2 ).  classmap  ( classMap ) - maps WSDL types to PHP classes; option must be an\n  array where keys are the WSDL types, and values are the PHP class to which\n  to map.  encoding  - internal character encoding (UTF-8 is always used as an external\n  encoding).  wsdl  - specifying this option sets the client in WSDL mode. Can be set\n  after-the-fact using  setWsdl($wsdl) .  uri  - target namespace for the SOAP service (required for non-WSDL-mode;\n  no-op when in WSDL mode).  location  - the URL to request (required for non-WSDL-mode; no-op when in\n  WSDL mode).  style  - request style (non-WSDL mode only); one of  SOAP_RPC  or\n   SOAP_DOCUMENT .  use  - method to use when encoding messages (non-WSDL mode only);\n  either  SOAP_ENCODED  or  SOAP_LITERAL .  login  and  password  - login and password for HTTP authentication.  proxy_host ,  proxy_port ,  proxy_login , and  proxy_password  - use when\n  specifying a service behind a proxy server.  local_cert  and  passphrase  - HTTPS client certificate authentication\n  options.  compression  - compression options; combination of\n   SOAP_COMPRESSION_ACCEPT ,  SOAP_COMPRESSION_GZIP  and/or\n   SOAP_COMPRESSION_DEFLATE  options.   The following demonstrate usage of compression options:  // Accept response compression\n$client = new Zend\\Soap\\Client(\n    'some.wsdl',\n    ['compression' => SOAP_COMPRESSION_ACCEPT]\n);\n\n// Compress requests using gzip with compression level 5\n$client = new Zend\\Soap\\Client(\n    'some.wsdl',\n    ['compression' => SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_GZIP | 5]\n);\n\n// Compress requests using deflate compression\n$client = new Zend\\Soap\\Client(\n    \"some.wsdl\",\n    ['compression' => SOAP_COMPRESSION_ACCEPT | SOAP_COMPRESSION_DEFLATE]\n);",
            "title": "Non-WSDL mode requirements"
        },
        {
            "location": "/client/#performing-soap-requests",
            "text": "After we've created a  Zend\\Soap\\Client  instance, we can perform SOAP requests.  Each web service method is mapped to a virtual  Zend\\Soap\\Client  instance\nmethod which takes parameters with common PHP types.  As an example, given the following server:  class MyClass\n{\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam\n     * @return string\n     */\n    public function method1($inputParam)\n    {\n        /* ... */\n    }\n\n    /**\n     * This method takes ...\n     *\n     * @param integer $inputParam1\n     * @param string  $inputParam2\n     * @return float\n     */\n    public function method2($inputParam1, $inputParam2)\n    {\n        /* ... */\n    }\n\n    /* ... */\n}\n\n$server = new Zend\\Soap\\Server(null, $options);\n$server->setClass('MyClass');\n$server->handle();  We can write a client as follows:  $client = new Zend\\Soap\\Client(\"MyService.wsdl\");\n\n// $result1 is a string\n$result1 = $client->method1(10);\n\n// $result2 is a float\n$result2 = $client->method2(22, 'some string');",
            "title": "Performing SOAP Requests"
        },
        {
            "location": "/wsdl/",
            "text": "WSDL Parsing and Generation\n\n\nThe \nZend\\Soap\\Wsdl\n class is used by \nZend\\Soap\\Server\n internally to operate\nwith WSDL documents. In most cases, you will not interact with it directly.\n\n\nNevertheless, you could also use functionality provided by this class for your\nown needs.  \nZend\\Soap\\Wsdl\n contains both a parser and a generator for WSDL\ndocuments.\n\n\nInstantiation\n\n\nThe \nZend\\Soap\\Wsdl\n constructor takes three parameters:\n\n\n\n\n$name\n - name of the web service being described.\n\n\n$uri\n - URI where the WSDL will be available (could also be a reference to\n  the file in the filesystem.)\n\n\n$strategy\n - optional flag used to identify the strategy for complex types\n  (objects) detection.  To read more on complex type detection strategies go to\n  the section on \nadding complex types\n.\n\n\n$classMap\n - Optional array of class name translations from PHP Type (key) to\n  WSDL type (value).\n\n\n\n\naddMessage() method\n\n\nThe \naddMessage($name, $parts)\n method adds a new message description to the\nWSDL document (\n/definitions/message\n element).\n\n\nEach message corresponds to methods in terms of \nZend\\Soap\\Server\n and\n\nZend\\Soap\\Client\n functionality.\n\n\nThe \n$name\n parameter represents the message name.\n\n\nThe \n$parts\n parameter is an array of message parts which describes SOAP call\nparameters, represented as an associative array of 'part name' (SOAP call\nparameter name) => 'part type' pairs.\n\n\nType mapping management is performed using one of the \naddTypes()\n and\n\naddComplexType()\n methods (see below).\n\n\n\n\nMessage Typing\n\n\nMessages parts can use either the \nelement\n or \ntype\n attribute for typing (see\n\nthe W3C WSDL specification\n).\n\n\nThe \nelement\n attribute must refer to a corresponding element in the data type\ndefinition. A \ntype\n attribute refers to a corresponding complexType entry.\n\n\nAll standard XSD types have both \nelement\n and \ncomplexType\n definitions (see\nthe \nSOAP encoding specification\n\nfor details).\n\n\nAll non-standard types, which may be added using the\n\nZend\\Soap\\Wsdl::addComplexType()\n method, are described using the\n\ncomplexType\n node of the \n/definitions/types/schema/\n section of the WSDL\ndocument.\n\n\nThe \naddMessage()\n method always uses the \ntype\n attribute to describe types.\n\n\n\n\naddPortType() method\n\n\nThe \naddPortType($name)\n method adds a new port type to the WSDL document\n(\n/definitions/portType\n) with the specified port type name.\n\n\nIn terms of the \nZend\\Soap\\Server\n implementation, it joins a set of web service\nmethods into a single operation.\n\n\nSee \nthe W3C portTypes documentation\n for\nmore details.\n\n\naddPortOperation() method\n\n\nThe \naddPortOperation($portType, $name, $input = false, $output = false, $fault\n= false)\n method adds new port operation to the specified port type of the WSDL\ndocument (\n/definitions/portType/operation\n).\n\n\nIn terms of the \nZend\\Soap\\Server\n implementation, Each port operation\ncorresponds to a class method (if the web service is based on a class) or\nfunction (if the web service is based on a set of methods).\n\n\nIt also adds corresponding port operation messages depending on the specified\n\n$input\n, \n$output\n and \n$fault\n parameters.\n\n\n\n\nGenerated messages\n\n\nZend\\Soap\\Server\n generates two messages for each port operation when\ndescribing operations it provides:\n\n\n\n\ninput message with name \n<$methodName>Request\n.\n\n\noutput message with name \n<$methodName>Response\n.\n\n\n\n\n\n\nSee the \nW3C WSDL request/response documentation\n\nfor more details.\n\n\naddBinding() method\n\n\nThe \naddBinding($name, $portType)\n method adds new binding to the WSDL document\n(\n/definitions/binding\n).\n\n\nA \nbinding\n WSDL document node defines the message format and protocol details\nfor operations and messages defined by a particular portType (see the \nW3C WSDL\nbinding documentation\n).\n\n\nThe method creates a binding node and returns it; you may then fill the returned\nnode with data.\n\n\nZend\\Soap\\Server\n uses the name \n<$serviceName>Binding\n for the 'binding'\nelement in the WSDL document.\n\n\naddBindingOperation() method\n\n\nThe \naddBindingOperation($binding, $name, $input = false, $output = false,\n$fault = false)\n method adds an operation to a binding element\n(\n/definitions/binding/operation\n) with the specified name.\n\n\nIt takes an \nXML_Tree_Node\n object returned by \naddBinding()\n as an input\n(\n$binding\n parameter) to add an 'operation' element with input/output/false\nentries depending on the specified parameters\n\n\nThe \nZend\\Soap\\Server\n implementation adds a corresponding binding entry for each web service method with\ninput and output entries, defining the \nsoap:body\n element as \n<soap:body use=\"encoded\"\nencodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n.\n\n\nSee the \nW3C WSDL bindings documentation\n\nfor more details.\n\n\naddSoapBinding() method\n\n\nThe \naddSoapBinding($binding, $style = 'document', $transport =\n'http://schemas.xmlsoap.org/soap/http')\n method adds a SOAP binding\n(\nsoap:binding\n) entry to the binding element (which is already linked to some\nport type) using the specified style and transport (the \nZend\\Soap\\Server\n\nimplementation uses the RPC style over HTTP).\n\n\nA \n/definitions/binding/soap:binding\n element is used to signify that the\nbinding is bound to the SOAP protocol format.\n\n\nSee the \nW3C bindings documentation\n for\nmore details.\n\n\naddSoapOperation() method\n\n\nThe \naddSoapOperation($binding, $soap_action)\n method adds a SOAP operation\n(\nsoap:operation\n) entry to the binding element with the specified action. The\n\nstyle\n attribute of the \nsoap:operation\n element is not used since the\nprogramming model (RPC-oriented or document-oriented) may be using the\n\naddSoapBinding()\n method already.\n\n\nThe \nsoapAction\n attribute of \n/definitions/binding/soap:operation\n element\nspecifies the value of the SOAP action header for this operation. This attribute\nis required for SOAP over HTTP and \nmust not\n be specified for other\ntransports.\n\n\nThe \nZend\\Soap\\Server\n implementation uses the format\n\n<$serviceUri>#<$methodName>\n for the SOAP operation action name.\n\n\nSee the \nW3C soap:operation documentation\n\nfor more details.\n\n\naddService() method\n\n\nThe \naddService($name, $port_name, $binding, $location)\n method adds a\n\n/definitions/service\n element to the WSDL document with the specified service\nname, port name, binding, and location.\n\n\nWSDL 1.1 allows several port types (sets of operations) per service; however,\nzend-soap does not support this ability.\n\n\nThe \nZend\\Soap\\Server\n implementation uses:\n\n\n\n\n<$name>Service\n as the service name.\n\n\n<$name>Port\n as the port type name.\n\n\ntns:<$name>Binding\n [1] as the binding name. (\ntns:namespace\n is defined as\n  the script URI; generally this is \n'http://' . $_SERVER['HTTP_HOST'] .\n  $_SERVER['SCRIPT_NAME']\n)\n\n\nthe script URI (\n'http://' . $_SERVER['HTTP_HOST'] .  $_SERVER['SCRIPT_NAME']\n)\n  as the service URI for the service definition.\n\n\n\n\nwhere \n$name\n is either:\n\n\n\n\na class name, for servers representing a PHP class,\n\n\na script name, for servers representing a collection of PHP functions.\n\n\n\n\nSee the \nW3C WSDL services documentation\n\nfor more details.\n\n\nType mapping\n\n\nThe zend-soap WSDL implementation uses the following type mappings between PHP\nand SOAP types:\n\n\n\n\nPHP strings <-> \nxsd:string\n.\n\n\nPHP integers <-> \nxsd:int\n.\n\n\nPHP floats and doubles <-> \nxsd:float\n.\n\n\nPHP booleans <-> \nxsd:boolean\n.\n\n\nPHP arrays <-> \nsoap-enc:Array\n.\n\n\nPHP object <-> \nxsd:struct\n.\n\n\nPHP class <-> based on complex type strategy (See\n  \nthe section on adding complex types\n).\n\n\nPHP void <-> empty type.\n\n\nIf a type is not matched to any of the above, then \nxsd:anyType\n is used.\n\n\n\n\nWhere:\n\n\n\n\nxsd:\n refers to the \nhttp://www.w3.org/2001/XMLSchema\n namespace\n\n\nsoap-enc:\n refers to the \nhttp://schemas.xmlsoap.org/soap/encoding/\n\n  namespace\n\n\ntns:\n is the \"target namespace\" for the service.\n\n\n\n\n\n\nComplex types\n\n\nBy default, \nZend\\Soap\\Wsdl\n will be created with the\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType\n class as its detection\nalgorithm for complex types. The first parameter of the \nAutoDiscover\n\nconstructor takes any complex type strategy implementing\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\ComplexTypeStrategyInterface\n, or a string\nclass name of a class implementing the interface. For backwards compatibility\nwith the \n$extractComplexType\n setting, boolean variables are parsed the\nfollowing way:\n\n\n\n\nIf \nTRUE\n, \nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType\n is used.\n\n\nIf \nFALSE\n, \nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\AnyType\n is used.\n\n\n\n\n\n\nRetrieving type information\n\n\nThe \ngetType($type)\n method may be used to retrieve the mapping for a specified\nPHP type:\n\n\n$wsdl = new Zend\\Soap\\Wsdl('My_Web_Service', $myWebServiceUri);\n$soapIntType = $wsdl->getType('int');\n\nclass MyClass\n{\n    /* ... */\n}\n\n$soapMyClassType = $wsdl->getType('MyClass');\n\n\n\n\nAdding complex type information\n\n\nThe \naddComplexType($type)\n method is used to add complex types (PHP classes) to\na WSDL document.\n\n\nThe method is automatically used by the \ngetType()\n method to add corresponding\ncomplex types of method parameters or return types.\n\n\nThe detection and generation algorithm it uses is based on the currently active\ndetection strategy for complex types. You can set the detection strategy either\nby specifying the class name as a string or providing an instance of a\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\n implementation as the third parameter to\nthe constructor, or by calling the \nsetComplexTypeStrategy($strategy)\n function\nof \nZend\\Soap\\Wsdl\n.\n\n\nThe following detection strategies currently exist:\n\n\n\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType\n: Enabled by default\n  (when no third constructor parameter is set). Iterates over the public\n  attributes of a class type and registers them as subtypes of the complex\n  object type.\n\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\AnyType\n: Casts all complex types into the\n  simple XSD type \nxsd:anyType\n. Warning: this shortcut for complex type\n  detection can probably only be handled successfully by weakly typed languages\n  such as PHP.\n\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\ArrayOfTypeSequence\n: This strategy allows\n  specifying arrays of the given type, which can be any PHP scalar type (\nint\n,\n  \nstring\n, \nbool\n, \nfloat\n), as well as objects or arrays of objects.\n\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\ArrayOfTypeComplex\n: This strategy allows\n  detecting very complex arrays of objects. Objects types are detected based on\n  the \nZend\\Soap\\Wsdl\\Strategy\\DefaultComplexType\n, and an array is wrapped\n  around that definition.\n\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\Composite\n: This strategy can combine all\n  strategies by connecting PHP complex types (classes/objects) to the desired\n  strategy via the \nconnectTypeToStrategy($type, $strategy)\n method. A complete\n  typemap can be given to the constructor as an array with \n$type\n / \n$strategy\n\n  pairs. The second parameter specifies the default strategy that will be used\n  if an unknown type is requested for adding, and defaults to the\n  \nZend\\Soap\\Wsdl\\Strategy\\DefaultComplexType\n strategy.\n\n\n\n\nThe \naddComplexType()\n method creates a\n\n/definitions/types/xsd:schema/xsd:complexType\n element for each described\ncomplex type, using the specified PHP class name.\n\n\nClass properties \nMUST\n have a docblock section with the described PHP type in\norder to be included in the WSDL description.\n\n\naddComplexType()\n checks if the type is already described within types section\nof the WSDL document, and prevents duplication of types. Additionally, it has\nrecursion detection.\n\n\nSee the \nW3C WSDL types documentation\n for\nmore details.\n\n\naddDocumentation() method\n\n\nThe \naddDocumentation($input_node, $documentation)\n method adds human readable\ndocumentation using the optional \nwsdl:document\n element.\n\n\nThe \n/definitions/binding/soap:binding\n element is used to signify that the\nbinding is bound to the SOAP protocol format.\n\n\nSee the \nW3C WSDL documentation section\n\nfor more details.\n\n\nRetrieve the final WSDL document\n\n\nSeveral methods exist for retrieving the full WSDL definition document:\n\n\n\n\ntoXML()\n will generate an XML string.\n\n\ntoDomDocument()\n will generate a PHP \nDOMDocument\n instance.\n\n\ndump($filename = false)\n will dump the XML to the specified filename, or, if\n  no filename is provided, return the XML string.",
            "title": "WSDL Parsing and Generation"
        },
        {
            "location": "/wsdl/#wsdl-parsing-and-generation",
            "text": "The  Zend\\Soap\\Wsdl  class is used by  Zend\\Soap\\Server  internally to operate\nwith WSDL documents. In most cases, you will not interact with it directly.  Nevertheless, you could also use functionality provided by this class for your\nown needs.   Zend\\Soap\\Wsdl  contains both a parser and a generator for WSDL\ndocuments.",
            "title": "WSDL Parsing and Generation"
        },
        {
            "location": "/wsdl/#instantiation",
            "text": "The  Zend\\Soap\\Wsdl  constructor takes three parameters:   $name  - name of the web service being described.  $uri  - URI where the WSDL will be available (could also be a reference to\n  the file in the filesystem.)  $strategy  - optional flag used to identify the strategy for complex types\n  (objects) detection.  To read more on complex type detection strategies go to\n  the section on  adding complex types .  $classMap  - Optional array of class name translations from PHP Type (key) to\n  WSDL type (value).",
            "title": "Instantiation"
        },
        {
            "location": "/wsdl/#addmessage-method",
            "text": "The  addMessage($name, $parts)  method adds a new message description to the\nWSDL document ( /definitions/message  element).  Each message corresponds to methods in terms of  Zend\\Soap\\Server  and Zend\\Soap\\Client  functionality.  The  $name  parameter represents the message name.  The  $parts  parameter is an array of message parts which describes SOAP call\nparameters, represented as an associative array of 'part name' (SOAP call\nparameter name) => 'part type' pairs.  Type mapping management is performed using one of the  addTypes()  and addComplexType()  methods (see below).",
            "title": "addMessage() method"
        },
        {
            "location": "/wsdl/#message-typing",
            "text": "Messages parts can use either the  element  or  type  attribute for typing (see the W3C WSDL specification ).  The  element  attribute must refer to a corresponding element in the data type\ndefinition. A  type  attribute refers to a corresponding complexType entry.  All standard XSD types have both  element  and  complexType  definitions (see\nthe  SOAP encoding specification \nfor details).  All non-standard types, which may be added using the Zend\\Soap\\Wsdl::addComplexType()  method, are described using the complexType  node of the  /definitions/types/schema/  section of the WSDL\ndocument.  The  addMessage()  method always uses the  type  attribute to describe types.",
            "title": "Message Typing"
        },
        {
            "location": "/wsdl/#addporttype-method",
            "text": "The  addPortType($name)  method adds a new port type to the WSDL document\n( /definitions/portType ) with the specified port type name.  In terms of the  Zend\\Soap\\Server  implementation, it joins a set of web service\nmethods into a single operation.  See  the W3C portTypes documentation  for\nmore details.",
            "title": "addPortType() method"
        },
        {
            "location": "/wsdl/#addportoperation-method",
            "text": "The  addPortOperation($portType, $name, $input = false, $output = false, $fault\n= false)  method adds new port operation to the specified port type of the WSDL\ndocument ( /definitions/portType/operation ).  In terms of the  Zend\\Soap\\Server  implementation, Each port operation\ncorresponds to a class method (if the web service is based on a class) or\nfunction (if the web service is based on a set of methods).  It also adds corresponding port operation messages depending on the specified $input ,  $output  and  $fault  parameters.",
            "title": "addPortOperation() method"
        },
        {
            "location": "/wsdl/#generated-messages",
            "text": "Zend\\Soap\\Server  generates two messages for each port operation when\ndescribing operations it provides:   input message with name  <$methodName>Request .  output message with name  <$methodName>Response .    See the  W3C WSDL request/response documentation \nfor more details.",
            "title": "Generated messages"
        },
        {
            "location": "/wsdl/#addbinding-method",
            "text": "The  addBinding($name, $portType)  method adds new binding to the WSDL document\n( /definitions/binding ).  A  binding  WSDL document node defines the message format and protocol details\nfor operations and messages defined by a particular portType (see the  W3C WSDL\nbinding documentation ).  The method creates a binding node and returns it; you may then fill the returned\nnode with data.  Zend\\Soap\\Server  uses the name  <$serviceName>Binding  for the 'binding'\nelement in the WSDL document.",
            "title": "addBinding() method"
        },
        {
            "location": "/wsdl/#addbindingoperation-method",
            "text": "The  addBindingOperation($binding, $name, $input = false, $output = false,\n$fault = false)  method adds an operation to a binding element\n( /definitions/binding/operation ) with the specified name.  It takes an  XML_Tree_Node  object returned by  addBinding()  as an input\n( $binding  parameter) to add an 'operation' element with input/output/false\nentries depending on the specified parameters  The  Zend\\Soap\\Server  implementation adds a corresponding binding entry for each web service method with\ninput and output entries, defining the  soap:body  element as  <soap:body use=\"encoded\"\nencodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"> .  See the  W3C WSDL bindings documentation \nfor more details.",
            "title": "addBindingOperation() method"
        },
        {
            "location": "/wsdl/#addsoapbinding-method",
            "text": "The  addSoapBinding($binding, $style = 'document', $transport =\n'http://schemas.xmlsoap.org/soap/http')  method adds a SOAP binding\n( soap:binding ) entry to the binding element (which is already linked to some\nport type) using the specified style and transport (the  Zend\\Soap\\Server \nimplementation uses the RPC style over HTTP).  A  /definitions/binding/soap:binding  element is used to signify that the\nbinding is bound to the SOAP protocol format.  See the  W3C bindings documentation  for\nmore details.",
            "title": "addSoapBinding() method"
        },
        {
            "location": "/wsdl/#addsoapoperation-method",
            "text": "The  addSoapOperation($binding, $soap_action)  method adds a SOAP operation\n( soap:operation ) entry to the binding element with the specified action. The style  attribute of the  soap:operation  element is not used since the\nprogramming model (RPC-oriented or document-oriented) may be using the addSoapBinding()  method already.  The  soapAction  attribute of  /definitions/binding/soap:operation  element\nspecifies the value of the SOAP action header for this operation. This attribute\nis required for SOAP over HTTP and  must not  be specified for other\ntransports.  The  Zend\\Soap\\Server  implementation uses the format <$serviceUri>#<$methodName>  for the SOAP operation action name.  See the  W3C soap:operation documentation \nfor more details.",
            "title": "addSoapOperation() method"
        },
        {
            "location": "/wsdl/#addservice-method",
            "text": "The  addService($name, $port_name, $binding, $location)  method adds a /definitions/service  element to the WSDL document with the specified service\nname, port name, binding, and location.  WSDL 1.1 allows several port types (sets of operations) per service; however,\nzend-soap does not support this ability.  The  Zend\\Soap\\Server  implementation uses:   <$name>Service  as the service name.  <$name>Port  as the port type name.  tns:<$name>Binding  [1] as the binding name. ( tns:namespace  is defined as\n  the script URI; generally this is  'http://' . $_SERVER['HTTP_HOST'] .\n  $_SERVER['SCRIPT_NAME'] )  the script URI ( 'http://' . $_SERVER['HTTP_HOST'] .  $_SERVER['SCRIPT_NAME'] )\n  as the service URI for the service definition.   where  $name  is either:   a class name, for servers representing a PHP class,  a script name, for servers representing a collection of PHP functions.   See the  W3C WSDL services documentation \nfor more details.",
            "title": "addService() method"
        },
        {
            "location": "/wsdl/#type-mapping",
            "text": "The zend-soap WSDL implementation uses the following type mappings between PHP\nand SOAP types:   PHP strings <->  xsd:string .  PHP integers <->  xsd:int .  PHP floats and doubles <->  xsd:float .  PHP booleans <->  xsd:boolean .  PHP arrays <->  soap-enc:Array .  PHP object <->  xsd:struct .  PHP class <-> based on complex type strategy (See\n   the section on adding complex types ).  PHP void <-> empty type.  If a type is not matched to any of the above, then  xsd:anyType  is used.   Where:   xsd:  refers to the  http://www.w3.org/2001/XMLSchema  namespace  soap-enc:  refers to the  http://schemas.xmlsoap.org/soap/encoding/ \n  namespace  tns:  is the \"target namespace\" for the service.",
            "title": "Type mapping"
        },
        {
            "location": "/wsdl/#complex-types",
            "text": "By default,  Zend\\Soap\\Wsdl  will be created with the Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType  class as its detection\nalgorithm for complex types. The first parameter of the  AutoDiscover \nconstructor takes any complex type strategy implementing Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\ComplexTypeStrategyInterface , or a string\nclass name of a class implementing the interface. For backwards compatibility\nwith the  $extractComplexType  setting, boolean variables are parsed the\nfollowing way:   If  TRUE ,  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType  is used.  If  FALSE ,  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\AnyType  is used.",
            "title": "Complex types"
        },
        {
            "location": "/wsdl/#retrieving-type-information",
            "text": "The  getType($type)  method may be used to retrieve the mapping for a specified\nPHP type:  $wsdl = new Zend\\Soap\\Wsdl('My_Web_Service', $myWebServiceUri);\n$soapIntType = $wsdl->getType('int');\n\nclass MyClass\n{\n    /* ... */\n}\n\n$soapMyClassType = $wsdl->getType('MyClass');",
            "title": "Retrieving type information"
        },
        {
            "location": "/wsdl/#adding-complex-type-information",
            "text": "The  addComplexType($type)  method is used to add complex types (PHP classes) to\na WSDL document.  The method is automatically used by the  getType()  method to add corresponding\ncomplex types of method parameters or return types.  The detection and generation algorithm it uses is based on the currently active\ndetection strategy for complex types. You can set the detection strategy either\nby specifying the class name as a string or providing an instance of a Zend\\Soap\\Wsdl\\ComplexTypeStrategy  implementation as the third parameter to\nthe constructor, or by calling the  setComplexTypeStrategy($strategy)  function\nof  Zend\\Soap\\Wsdl .  The following detection strategies currently exist:   Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType : Enabled by default\n  (when no third constructor parameter is set). Iterates over the public\n  attributes of a class type and registers them as subtypes of the complex\n  object type.  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\AnyType : Casts all complex types into the\n  simple XSD type  xsd:anyType . Warning: this shortcut for complex type\n  detection can probably only be handled successfully by weakly typed languages\n  such as PHP.  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\ArrayOfTypeSequence : This strategy allows\n  specifying arrays of the given type, which can be any PHP scalar type ( int ,\n   string ,  bool ,  float ), as well as objects or arrays of objects.  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\ArrayOfTypeComplex : This strategy allows\n  detecting very complex arrays of objects. Objects types are detected based on\n  the  Zend\\Soap\\Wsdl\\Strategy\\DefaultComplexType , and an array is wrapped\n  around that definition.  Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\Composite : This strategy can combine all\n  strategies by connecting PHP complex types (classes/objects) to the desired\n  strategy via the  connectTypeToStrategy($type, $strategy)  method. A complete\n  typemap can be given to the constructor as an array with  $type  /  $strategy \n  pairs. The second parameter specifies the default strategy that will be used\n  if an unknown type is requested for adding, and defaults to the\n   Zend\\Soap\\Wsdl\\Strategy\\DefaultComplexType  strategy.   The  addComplexType()  method creates a /definitions/types/xsd:schema/xsd:complexType  element for each described\ncomplex type, using the specified PHP class name.  Class properties  MUST  have a docblock section with the described PHP type in\norder to be included in the WSDL description.  addComplexType()  checks if the type is already described within types section\nof the WSDL document, and prevents duplication of types. Additionally, it has\nrecursion detection.  See the  W3C WSDL types documentation  for\nmore details.",
            "title": "Adding complex type information"
        },
        {
            "location": "/wsdl/#adddocumentation-method",
            "text": "The  addDocumentation($input_node, $documentation)  method adds human readable\ndocumentation using the optional  wsdl:document  element.  The  /definitions/binding/soap:binding  element is used to signify that the\nbinding is bound to the SOAP protocol format.  See the  W3C WSDL documentation section \nfor more details.",
            "title": "addDocumentation() method"
        },
        {
            "location": "/wsdl/#retrieve-the-final-wsdl-document",
            "text": "Several methods exist for retrieving the full WSDL definition document:   toXML()  will generate an XML string.  toDomDocument()  will generate a PHP  DOMDocument  instance.  dump($filename = false)  will dump the XML to the specified filename, or, if\n  no filename is provided, return the XML string.",
            "title": "Retrieve the final WSDL document"
        },
        {
            "location": "/auto-discovery/",
            "text": "AutoDiscovery\n\n\nSOAP functionality implemented within this component is intended to make all\nsteps required for SOAP communications more simple. SOAP is a language\nindependent protocol, however, which means it may be used for more than just\nPHP-to-PHP communications, adding some complexity to its implementation.\n\n\nThere are three configurations for SOAP applications supported by zend-soap:\n\n\n\n\nSOAP server PHP application <---> SOAP client PHP application\n\n\nSOAP server non-PHP application <---> SOAP client PHP application\n\n\nSOAP server PHP application <---> SOAP client non-PHP application\n\n\n\n\nIn each situation, the SOAP server must expose the functionality it provides so\nthe client knows how to interact with it. This is done via a\n\nWSDL\n (Web Services Description Language) document.\nThe WSDL language is quite complex, making preparation of WSDL documents\ndifficult; this task is complicated when the API for your service changes, as\nany changes then need to be synced back to the WSDL.\n\n\nThese problems may be solved via WSDL autodiscovery, which zend-soap provides\nvia its \nZend\\Soap\\AutoDiscover\n class.\n\n\nAutodiscovery in zend-soap follows the same patterns as you use for creating a\nzend-soap \nServer\n, but uses the classes and functions attached to it to extract\nthe information required to generate a WSDL document.\n\n\nAs a refresher, zend-soap allows using either of the following to define a\nserver:\n\n\n\n\nPHP classes.\n\n\nPHP functions.\n\n\n\n\nEach are also supported by the autodiscovery functionality. Additionally,\n\nAutoDiscover\n supports datatype mappins from PHP to \nXSD types\n.\n\n\nThe following is a basic example demonstrating the autodiscovery functionality.\nIt uses similar functionality as when using \nZend\\Soap\\Server\n, but\ninstead of using \nhandle()\n to handle an incoming SOAP request, it provides a\n\ngenerate()\n method, which returns a \nZend\\Soap\\Wsdl\n instance. This\ncan then be used to return an XML representation to the client.\n\n\nclass MySoapServerClass\n{\n    /* ... */\n}\n\n$autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover\n    ->setClass('MySoapServerClass')\n    ->setUri('http://localhost/server.php')\n    ->setServiceName('MySoapService');\n\n$wsdl = $autodiscover->generate();\n\n// Emit the XML:\necho $wsdl->toXml();\n\n// Or dump it to a file; this is a good way to cache the WSDL\n$wsdl->dump(\"/path/to/file.wsdl\");\n\n// Or create a DOMDocument, which you can then manipulate:\n$dom = $wsdl->toDomDocument();\n\n\n\n\n\n\nAutoDiscover !== Server\n\n\nAutoDiscover\n \nis not a \nServer\n instance\n; it cannot and does not act as a\nSOAP server on its own, but instead provides the WSDL used by clients that\nwill interact with your SOAP server.\n\n\nSOAP interactions are always performed over HTTP POST requests, while\nretrieval of WSDL is performed using HTTP GET. As such, you \ncan\n server both\nfrom the same script, provided you detect the incoming method and respond\naccordingly:\n\n\nif ($_SERVER['REQUEST_METHOD'] == 'GET') {\n    if (! isset($_GET['wsdl'])) {\n        header('HTTP/1.1 400 Client Error');\n        return;\n    }\n\n    $autodiscover = new Zend\\Soap\\AutoDiscover();\n    $autodiscover->setClass('HelloWorldService')\n        ->setUri('http://example.com/soap.php');\n    header('Content-Type: application/wsdl+xml');\n    echo $autodiscover->toXml();\n    return;\n}\n\nif ($_SERVER['REQUEST_METHOD'] != 'POST') {\n    header('HTTP/1.1 400 Client Error');\n    return;\n}\n\n// pointing to the current file here\n$soap = new Zend\\Soap\\Server(\"http://example.com/soap.php?wsdl\");\n$soap->setClass('HelloWorldService');\n$soap->handle();\n\n\n\n\n\n\nClass autodiscovery\n\n\nIf a class is used to provide SOAP server functionality, then the same class\nshould be provided to \nZend\\Soap\\AutoDiscover\n for WSDL generation:\n\n\n$autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover\n    ->setClass('My_SoapServer_Class')\n    ->setUri('http://localhost/server.php')\n    ->setServiceName('MySoapService');\n$wsdl = $autodiscover->generate();\n\n\n\n\nThe following rules are used during WSDL generation:\n\n\n\n\nThe generated WSDL describes an RPC/Encoded style web service. If you want to\n  describe a document/literal server, use the \nsetBindingStyle()\n and\n  \nsetOperationBodyStyle()\n methods.\n\n\nThe PHP class name is used as the web service name unless \nsetServiceName()\n\n  is used explicitly to set the name. When only functions are used, the service\n  name has to be set explicitly or an exception will be thrown during WSDL\n  document generation.\n\n\nYou can set the endpoint of the actual SOAP Server via the \nsetUri()\n method.\n  This is a required option, and also used as the target namespace for all\n  service related names (including described complex types).\n\n\n\n\nComplex types are generated using the following rules:\n\n\n\n\nClass methods are joined into one \nPort Type\n,\n  with port names using the format \n<$serviceName>Port\n.\n\n\nEach class method/function is registered as a corresponding port operation.\n\n\nOnly the \"longest\" available method prototype is used for WSDL generation.\n\n\nWSDL autodiscovery utilizes PHP docblocks provided by the developer to determine the\n  parameter and return types. In fact, for scalar types, this is the only way to\n  determine the parameter types, and for return types, this is the only way to\n  determine them.  This means that \nproviding correct and fully detailed\n  docblocks is not only best practice, but required for autodiscovery\n.\n\n\n\n\nFunction autodiscovery\n\n\nIf a set of functions are used to provide your SOAP server functionality, then\nthe same set should be provided to \nZend\\Soap\\AutoDiscovery\n for WSDL\ngeneration:\n\n\n$autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover->addFunction('function1');\n$autodiscover->addFunction('function2');\n$autodiscover->addFunction('function3');\n\n$wsdl = $autodiscover->generate();\n\n\n\n\nThe same rules apply to generation as described in the class autodiscovery section above.\n\n\nAutodiscovering Datatypes\n\n\nInput/output datatypes are converted into network service types using the\nfollowing mapping:\n\n\n\n\nPHP strings <-> \nxsd:string\n.\n\n\nPHP integers <-> \nxsd:int\n.\n\n\nPHP floats and doubles <-> \nxsd:float\n.\n\n\nPHP booleans <-> \nxsd:boolean\n.\n\n\nPHP arrays <-> \nsoap-enc:Array\n.\n\n\nPHP object <-> \nxsd:struct\n.\n\n\nPHP class <-> based on complex type strategy (See the \nWSDL section on adding complex types\n).\n\n\ntype[] or object[] (ie. int[]) <-> based on complex type strategy\n\n\nPHP void <-> empty type.\n\n\nIf type is not matched to any of these types by some reason, then \nxsd:anyType\n is used.\n\n\n\n\nWhere:\n\n\n\n\nxsd:\n refers to the \nhttp://www.w3.org/2001/XMLSchema\n\n  namespace\n\n\nsoap-enc:\n refers to the \nhttp://schemas.xmlsoap.org/soap/encoding/\n\n  namespace\n\n\ntns:\n is the \"target namespace\" for the service.\n\n\n\n\n\n\nComplex type discovery\n\n\nZend\\Soap\\AutoDiscover\n will be created with the\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType\n class as its detection\nalgorithm for complex types. The first parameter of the \nAutoDiscover\n\nconstructor takes any complex type strategy implementing\n\nZend\\Soap\\Wsdl\\ComplexTypeStrategy\\ComplexTypeStrategyInterface\n (or a string\nclass name of an implementation).  name of the class. See the\n\nZend\\Soap\\Wsdl documentation on adding complex types\n\nfor more information.\n\n\n\n\nWSDL Binding Styles\n\n\nWSDL offers different transport mechanisms and styles. This affects the\n\nsoap:binding\n and \nsoap:body\n tags within the \nBinding\n section of the WSDL\ndocument. Different clients have different requirements as to what options\nreally work. Therefore you can set the styles before you call either the\n\nsetClass()\n or \naddFunction()\n method on the \nAutoDiscover\n class.\n\n\n$autodiscover = new Zend\\Soap\\AutoDiscover();\n\n// Defaults are\n// - 'use' => 'encoded'\n// - 'encodingStyle' => 'http://schemas.xmlsoap.org/soap/encoding/'\n$autodiscover->setOperationBodyStyle([\n    'use'       => 'literal',\n    'namespace' => 'http://framework.zend.com',\n]);\n\n// Defaults are:\n// - 'style' => 'rpc'\n// - 'transport' => 'http://schemas.xmlsoap.org/soap/http'\n$autodiscover->setBindingStyle([\n    'style'     => 'document',\n    'transport' => 'http://framework.zend.com',\n]);\n\n$autodiscover->addFunction('myfunc1');\n$wsdl = $autodiscover->generate();",
            "title": "WSDL AutoDiscovery"
        },
        {
            "location": "/auto-discovery/#autodiscovery",
            "text": "SOAP functionality implemented within this component is intended to make all\nsteps required for SOAP communications more simple. SOAP is a language\nindependent protocol, however, which means it may be used for more than just\nPHP-to-PHP communications, adding some complexity to its implementation.  There are three configurations for SOAP applications supported by zend-soap:   SOAP server PHP application <---> SOAP client PHP application  SOAP server non-PHP application <---> SOAP client PHP application  SOAP server PHP application <---> SOAP client non-PHP application   In each situation, the SOAP server must expose the functionality it provides so\nthe client knows how to interact with it. This is done via a WSDL  (Web Services Description Language) document.\nThe WSDL language is quite complex, making preparation of WSDL documents\ndifficult; this task is complicated when the API for your service changes, as\nany changes then need to be synced back to the WSDL.  These problems may be solved via WSDL autodiscovery, which zend-soap provides\nvia its  Zend\\Soap\\AutoDiscover  class.  Autodiscovery in zend-soap follows the same patterns as you use for creating a\nzend-soap  Server , but uses the classes and functions attached to it to extract\nthe information required to generate a WSDL document.  As a refresher, zend-soap allows using either of the following to define a\nserver:   PHP classes.  PHP functions.   Each are also supported by the autodiscovery functionality. Additionally, AutoDiscover  supports datatype mappins from PHP to  XSD types .  The following is a basic example demonstrating the autodiscovery functionality.\nIt uses similar functionality as when using  Zend\\Soap\\Server , but\ninstead of using  handle()  to handle an incoming SOAP request, it provides a generate()  method, which returns a  Zend\\Soap\\Wsdl  instance. This\ncan then be used to return an XML representation to the client.  class MySoapServerClass\n{\n    /* ... */\n}\n\n$autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover\n    ->setClass('MySoapServerClass')\n    ->setUri('http://localhost/server.php')\n    ->setServiceName('MySoapService');\n\n$wsdl = $autodiscover->generate();\n\n// Emit the XML:\necho $wsdl->toXml();\n\n// Or dump it to a file; this is a good way to cache the WSDL\n$wsdl->dump(\"/path/to/file.wsdl\");\n\n// Or create a DOMDocument, which you can then manipulate:\n$dom = $wsdl->toDomDocument();",
            "title": "AutoDiscovery"
        },
        {
            "location": "/auto-discovery/#autodiscover-server",
            "text": "AutoDiscover   is not a  Server  instance ; it cannot and does not act as a\nSOAP server on its own, but instead provides the WSDL used by clients that\nwill interact with your SOAP server.  SOAP interactions are always performed over HTTP POST requests, while\nretrieval of WSDL is performed using HTTP GET. As such, you  can  server both\nfrom the same script, provided you detect the incoming method and respond\naccordingly:  if ($_SERVER['REQUEST_METHOD'] == 'GET') {\n    if (! isset($_GET['wsdl'])) {\n        header('HTTP/1.1 400 Client Error');\n        return;\n    }\n\n    $autodiscover = new Zend\\Soap\\AutoDiscover();\n    $autodiscover->setClass('HelloWorldService')\n        ->setUri('http://example.com/soap.php');\n    header('Content-Type: application/wsdl+xml');\n    echo $autodiscover->toXml();\n    return;\n}\n\nif ($_SERVER['REQUEST_METHOD'] != 'POST') {\n    header('HTTP/1.1 400 Client Error');\n    return;\n}\n\n// pointing to the current file here\n$soap = new Zend\\Soap\\Server(\"http://example.com/soap.php?wsdl\");\n$soap->setClass('HelloWorldService');\n$soap->handle();",
            "title": "AutoDiscover !== Server"
        },
        {
            "location": "/auto-discovery/#class-autodiscovery",
            "text": "If a class is used to provide SOAP server functionality, then the same class\nshould be provided to  Zend\\Soap\\AutoDiscover  for WSDL generation:  $autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover\n    ->setClass('My_SoapServer_Class')\n    ->setUri('http://localhost/server.php')\n    ->setServiceName('MySoapService');\n$wsdl = $autodiscover->generate();  The following rules are used during WSDL generation:   The generated WSDL describes an RPC/Encoded style web service. If you want to\n  describe a document/literal server, use the  setBindingStyle()  and\n   setOperationBodyStyle()  methods.  The PHP class name is used as the web service name unless  setServiceName() \n  is used explicitly to set the name. When only functions are used, the service\n  name has to be set explicitly or an exception will be thrown during WSDL\n  document generation.  You can set the endpoint of the actual SOAP Server via the  setUri()  method.\n  This is a required option, and also used as the target namespace for all\n  service related names (including described complex types).   Complex types are generated using the following rules:   Class methods are joined into one  Port Type ,\n  with port names using the format  <$serviceName>Port .  Each class method/function is registered as a corresponding port operation.  Only the \"longest\" available method prototype is used for WSDL generation.  WSDL autodiscovery utilizes PHP docblocks provided by the developer to determine the\n  parameter and return types. In fact, for scalar types, this is the only way to\n  determine the parameter types, and for return types, this is the only way to\n  determine them.  This means that  providing correct and fully detailed\n  docblocks is not only best practice, but required for autodiscovery .",
            "title": "Class autodiscovery"
        },
        {
            "location": "/auto-discovery/#function-autodiscovery",
            "text": "If a set of functions are used to provide your SOAP server functionality, then\nthe same set should be provided to  Zend\\Soap\\AutoDiscovery  for WSDL\ngeneration:  $autodiscover = new Zend\\Soap\\AutoDiscover();\n$autodiscover->addFunction('function1');\n$autodiscover->addFunction('function2');\n$autodiscover->addFunction('function3');\n\n$wsdl = $autodiscover->generate();  The same rules apply to generation as described in the class autodiscovery section above.",
            "title": "Function autodiscovery"
        },
        {
            "location": "/auto-discovery/#autodiscovering-datatypes",
            "text": "Input/output datatypes are converted into network service types using the\nfollowing mapping:   PHP strings <->  xsd:string .  PHP integers <->  xsd:int .  PHP floats and doubles <->  xsd:float .  PHP booleans <->  xsd:boolean .  PHP arrays <->  soap-enc:Array .  PHP object <->  xsd:struct .  PHP class <-> based on complex type strategy (See the  WSDL section on adding complex types ).  type[] or object[] (ie. int[]) <-> based on complex type strategy  PHP void <-> empty type.  If type is not matched to any of these types by some reason, then  xsd:anyType  is used.   Where:   xsd:  refers to the  http://www.w3.org/2001/XMLSchema \n  namespace  soap-enc:  refers to the  http://schemas.xmlsoap.org/soap/encoding/ \n  namespace  tns:  is the \"target namespace\" for the service.",
            "title": "Autodiscovering Datatypes"
        },
        {
            "location": "/auto-discovery/#complex-type-discovery",
            "text": "Zend\\Soap\\AutoDiscover  will be created with the Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\DefaultComplexType  class as its detection\nalgorithm for complex types. The first parameter of the  AutoDiscover \nconstructor takes any complex type strategy implementing Zend\\Soap\\Wsdl\\ComplexTypeStrategy\\ComplexTypeStrategyInterface  (or a string\nclass name of an implementation).  name of the class. See the Zend\\Soap\\Wsdl documentation on adding complex types \nfor more information.",
            "title": "Complex type discovery"
        },
        {
            "location": "/auto-discovery/#wsdl-binding-styles",
            "text": "WSDL offers different transport mechanisms and styles. This affects the soap:binding  and  soap:body  tags within the  Binding  section of the WSDL\ndocument. Different clients have different requirements as to what options\nreally work. Therefore you can set the styles before you call either the setClass()  or  addFunction()  method on the  AutoDiscover  class.  $autodiscover = new Zend\\Soap\\AutoDiscover();\n\n// Defaults are\n// - 'use' => 'encoded'\n// - 'encodingStyle' => 'http://schemas.xmlsoap.org/soap/encoding/'\n$autodiscover->setOperationBodyStyle([\n    'use'       => 'literal',\n    'namespace' => 'http://framework.zend.com',\n]);\n\n// Defaults are:\n// - 'style' => 'rpc'\n// - 'transport' => 'http://schemas.xmlsoap.org/soap/http'\n$autodiscover->setBindingStyle([\n    'style'     => 'document',\n    'transport' => 'http://framework.zend.com',\n]);\n\n$autodiscover->addFunction('myfunc1');\n$wsdl = $autodiscover->generate();",
            "title": "WSDL Binding Styles"
        }
    ]
}